<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c4{-webkit-text-decoration-skip:none;color:#000000;font-weight:400;text-decoration:underline;vertical-align:baseline;text-decoration-skip-ink:none;font-size:11pt;font-family:"Arial";font-style:normal}.c6{color:#121212;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:23pt;font-family:"Arial";font-style:normal}.c9{padding-top:24pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:center}.c8{padding-top:20pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c14{padding-top:18pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:center}.c5{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:16pt;font-family:"Arial";font-style:normal}.c3{padding-top:18pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c7{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:20pt;font-family:"Arial";font-style:normal}.c0{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c1{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c11{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c2{height:11pt}.c12{font-weight:700}.c13{height:20pt}.c10{text-indent:36pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c11 doc-content"><div><p class="c1 c2"><span class="c0"></span></p></div><h1 class="c9" id="h.mg9u5axurju5"><span class="c6">CS 184/284A: Computer Graphics and Imaging, Spring 2024</span></h1><h1 class="c9" id="h.i0bqn14qmjhi"><span class="c6">Homework 1: Rasterizer</span></h1><h2 class="c14" id="h.tlp6ttvzvlbx"><span class="c5">Srikar Talluri 3036580613</span></h2><h1 class="c8 c13" id="h.9ndekwn3uzx6"><span class="c7"></span></h1><p class="c1 c2"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c1 c2"><span class="c0"></span></p><h1 class="c8" id="h.f99a94cf6cb7"><span class="c7">Overview</span></h1><p class="c1 c2"><span class="c0"></span></p><p class="c1 c10"><span class="c0">This homework was an involved and hands-on approach into the world of rasterization. Through building up basics such as single-color triangle rasterization, antialiasing via grid-based supersampling, and transformations, I was able to actually practice and implement myself the things I have learned and reviewed in lectures. And through the use of the GUI, I was able to physically see the effects of such techniques smooth out jaggies or interpolate colors across triangles. And the latter half of the homework dived into some advanced topics such as methods of pixel sampling and level sampling as ways to visually enhance the quality of a render. Probably the most interesting takeaway for me is the nearly unlimited freedom that graphics implementers have in terms of trying to make things render smoothly, fast, and lightly. When learning computer science as a student, there are usually a couple of clear cut solutions to most problems but it is not that way when it comes to rasterization, and computer graphics in general.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c1 c2"><span class="c0"></span></p><h1 class="c8" id="h.wubrwu4fsop3"><span class="c7">Section I: Rasterization</span></h1><p class="c1 c2"><span class="c0"></span></p><h2 class="c3" id="h.541zv2qvv6t"><span class="c5">Part 1: Rasterizing single-color triangles</span></h2><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">I rasterize triangles by first finding the bounding box around the triangle. This means that I take the xmin, ymin, xmax, ymax of the 3 coordinates and create a &ldquo;frame&rdquo; around the triangle. This is to ensure that I am only checking the points that may possibly fall in the triangle rather than points far away. Thus my algorithm performs no worse than one that checks each sample within the bounding box of the triangle.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">To check if a point is actually inside a triangle, I calculate the normal vectors of a point to each of the vectors that represent the edge. I ensure to keep the vectors all facing one way (either all clockwise or all anticlockwise). Thus if all the normal vectors have the same sign, then we know it must exist inside the triangle. (It cannot be true that a point lies outside the triangle and has all normal vectors with the same sign, regardless of orientation of points).</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 549.50px; height: 429.74px;"><img alt="" src="images/image5.png" style="width: 549.50px; height: 429.74px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0">screenshot of basic/test4.svg with the default viewing parameters and with the pixel inspector centered on an interesting part of the scene.</span></p><p class="c1"><span class="c0">Extra Credit:</span></p><p class="c1"><span class="c0">For optimizations, I noticed there were a lot of repeated computitons and multiplications that had to be done, especially when computing normal vectors from an edge to an arbitrary point. I also made use of the cgl library to use Vector3D. I am not sure if this in and of itself made a significant difference. One main different is that I made to sure take out computations of loops such as the computation of the normal vectors for y when I am looping through x (There is no need to compute normal vectors for the y coordinate when I am only changing the x and vice versa). As such, I precomputed these values outside of the loops, which resulted in significant speedups. This was also possible by changin the order of looping. (I first looped through dx and dy, the change in coordinates per pixel needed for supersampling, does not affect anything in this section).</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Unoptimized:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 254.67px;"><img alt="" src="images/image24.png" style="width: 624.00px; height: 254.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Optimized:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 574.50px; height: 280.81px;"><img alt="" src="images/image23.png" style="width: 574.50px; height: 280.81px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0">For Brevity, the time tables are below. I re rendered both codes several times to ensure enough variance. </span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 273.50px; height: 281.51px;"><img alt="" src="images/image24.png" style="width: 1365.31px; height: 558.18px; margin-left: -921.15px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 296.00px; height: 225.00px;"><img alt="" src="images/image18.png" style="width: 296.00px; height: 225.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c1 c2"><span class="c0"></span></p><h2 class="c3" id="h.ulqsocdbkp7j"><span class="c5">Part 2: Antialiasing triangles</span></h2><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Super sampling as a method to rasterize is very useful as it allows us to capture more granularity in our images without having to increase our physical screen resolutions. This effect becomes especially noticeable at edges or thin lines. It effectively allows us to blur pixels to create the effect of a smooth edge rather than a jagged edge.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">My supersampling algorithm was fairly textbook.</span></p><p class="c1"><span class="c0">First before I started sampling, I had to change some elements of the rasterization pipeline. I made sure to change the sample_buffer size to be of size (width * height * sample_rate). It represents a flattened 3D array. To index into this array to get a color given an x, y, and sample index, k, we can do sample_buffer[y * width * sample_rate + x * sample_rate + k]. </span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">This also meant that I had to change the implementation of resolve_to_framebuffer function. Instead of looping through width * height coordinates and simply assigning the color we found in the sample buffer to the frame buffer, we had to start averaging across all k&rsquo;s given x and y.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">For example if we found 2 red pixel samples and 2 default white pixel samples in a pixel. The resulting frame buffer pixel would have a light red pixel in it. </span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">As for the actual rasterization itself, I added in an extra two for loops (one for dx and one for dy) for an added complexity of O(sample_rate). For every x and y, we sample sample_rate points and save those in our sample buffer. I memoized the dx and dy to more easily get the super sampled points within a pixel: </span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 21.33px;"><img alt="" src="images/image21.png" style="width: 624.00px; height: 21.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">My supersmapling algorithm allowed me to antialias well as rather than just taking the middle of the pixel and checking if that is within a triangle, I check various uniformly placed points around the pixel. If some of where not in the triangle, then it stands to reason that it might be on the edge of the triangle thus we want to soften the pixel so the jagged edges aren&rsquo;t as apparent. This is an antialiasing method shown in class and was very effective as seen below. </span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Sample_rate = 1:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 515.50px; height: 386.63px;"><img alt="" src="images/image8.png" style="width: 515.50px; height: 386.63px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">sample_rate = 4:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 538.50px; height: 404.42px;"><img alt="" src="images/image22.png" style="width: 538.50px; height: 404.42px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0">sample_rate = 9:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 534.57px; height: 399.10px;"><img alt="" src="images/image9.png" style="width: 534.57px; height: 399.10px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0">sample_rate = 16:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 533.50px; height: 399.88px;"><img alt="" src="images/image20.png" style="width: 533.50px; height: 399.88px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0">Extra Credit:</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">My supersampling method checked uniform points. This meant that I was first splitting a pixel into 4, 9, or 16 sub-pixels and then checking if the centers of each of those were in the triangle. However, this subdivision may not be the best approach as it will always remain the same. As such I implemented random sampling. </span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">The basic approach is instead of checking the 4 centers of the subsquares, I check 4 random points in the pixel. The difference can be seen below</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Random sampling with sample rate = 1</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 500.50px; height: 369.42px;"><img alt="" src="images/image1.png" style="width: 500.50px; height: 369.42px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0">Edges are very jagged and nondeterministic</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">sample_rate = 16</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 507.50px; height: 381.44px;"><img alt="" src="images/image19.png" style="width: 507.50px; height: 381.44px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span>However with the sample_rate increased we see that the antialiasing becomes stronger and somewhat converges to what gridbased supersampling looks like. </span><hr style="page-break-before:always;display:none;"></p><h2 class="c3" id="h.huttvh2e305g"><span class="c5">Part 3: Transforms</span></h2><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">For my_robot, I made my robot jump and I also changed the color of his face. This could potentially be from hitting his head on the ceiling.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 488.00px;"><img alt="" src="images/image10.png" style="width: 624.00px; height: 488.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Extra Credit:</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span>For extra credit, I programmed the J button to be jump. This button switches between the my_robot.svg and robot.svg. The purpose of this allows us to press J really fast and it will look like the robot is jumping and hitting his head.</span><hr style="page-break-before:always;display:none;"></p><h1 class="c8" id="h.84hf586no3ve"><span class="c7">Section II: Sampling</span></h1><h2 class="c3" id="h.qzvq76x02x17"><span class="c5">Part 4: Barycentric coordinates</span></h2><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Imagine a line with points A and B. For any arbitrary point C, we can find two values alpha and beta that sum to one that allows us to determine where C is in relation to A and B. To recover C from A and B, we can take a weighted sum of A and B based on alpha and beta. </span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 152.00px;"><img alt="" src="images/image4.png" style="width: 624.00px; height: 152.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Similar to a line example, we can extend this out toward a triangle. Any point can be described by its relation to each of the 3 points of a triangle, or more accurately the 3 edges of the triangle.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">It is important to note that this method works for points outside of A and B as well, just that some values will be negative.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 610.00px; height: 332.00px;"><img alt="" src="images/image7.png" style="width: 610.00px; height: 332.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Here is a triangle with each vertex colored r, g, and b. Every point in the middle of the triangle is expressed as some weighted sum of the three points at the end. </span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Screenshot:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 498.67px;"><img alt="" src="images/image15.png" style="width: 624.00px; height: 498.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">png screenshot of svg/basic/test7.svg with default viewing parameters and sample rate 1</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c1 c2"><span class="c0"></span></p><h2 class="c3" id="h.labalvmlsvrm"><span class="c5">Part 5: &quot;Pixel sampling&quot; for texture mapping</span></h2><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">At its heart, pixel sampling is the way we apply a certain texture to the surface of a 3D model. For example, applying a wood grain finish to a floor model in a video game or screen is something we cannot do unless we have a way to &ldquo;stick&rdquo; the grain on the floor. Without it, we would have to re-create the floor from scratch by hand envisioning the pixels from a 3D perspective which is incredibly hard and laborious. It allows us to take into consideration perspective and distortion, both of which are important. </span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Pixel sampling especially comes into play when decides how a texel, or texture element, is applied to a pixel on a rendered image. In our case a texel is a color but can be other things in other use cases. There are two main ways to decide what texel to use for a given point.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">First is Nearest Neighbor. This is the simpler method of the two. It selects the nearest texel (in terms of uv coordinate norm) and returns that. This essentially creates squares around each texel so the resulting image can look a little pixelated. </span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Second in Bilinear sampling. Instead of selecting the nearest texel , we look at the texels that exist in the unit frame around the given texel. (basically selecting the 4 nearest texels). Then by taking a weighted average of these 4 texels (based on the given uv&rsquo;s location) we can return a (possibly) new texel. This is similar to how we &ldquo;average&rdquo; three points to find barycentric coordinates. </span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">nearest sampling at 1 sample per pixel</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 519.82px; height: 389.10px;"><img alt="" src="images/image16.png" style="width: 519.82px; height: 389.10px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">nearest sampling at 16 samples per pixel</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 505.71px; height: 379.28px;"><img alt="" src="images/image6.png" style="width: 505.71px; height: 379.28px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">bilinear sampling at 1 sample per pixel</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 494.50px; height: 370.88px;"><img alt="" src="images/image14.png" style="width: 494.50px; height: 370.88px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">bilinear sampling at 16 samples per pixel.</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 473.50px; height: 355.13px;"><img alt="" src="images/image17.png" style="width: 473.50px; height: 355.13px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">On the world map I chose to focus on the country of Italy as it is a relatively small country with a lot of inherent jaggies built into the landscape.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Already when comparing the pictures with 1 sample per pixel, it can already be seen that bilinear sampling significantly reduces the jaggies. The landmass of Italy has a continuously changing landscape color </span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 279.00px; height: 249.00px;"><img alt="" src="images/image2.png" style="width: 279.00px; height: 249.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0">From Google Maps</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">The colors of the landmass in real life do not change abruptly but flow from one shade of greens and browns to another. However when comparing the nearest neighbor to bilinear sampling at 1 sample per pixel, the nearest neighbor picture looks very pixelated both from the naked eye and zoomed in.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">When increasing the sample size, it can be seen that both of the images get better but the bilinear does not get significantly better. The difference between the images however still exists. When focusing on the heel of the boot (the rightmost little peninsula), the nearest neighbor still looks very pixelated and does not look natural. This compared to the bilinear sampling image where the heel now looks smoother and blended into the sea around it making for a much cleaner image. </span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span>There exist times when one sampling method may be far superior to the other in terms of picture quality. In our case, there exists a lot of pixels that need to be smoothed to create a map that isn&rsquo;t blocky or jaggied. This would be especially useful when trying to rasterize an image with a lot of gradients and quickly changing colors. Conversely, a nearest neighbor sampling method might far outshine a bilinear method if there exist clearly delineated, large, &nbsp;chunks of color that shouldn&rsquo;t really be blended together (Think a rubiks cube or maybe legos). In this case, a nearest neighbor would be better.</span><hr style="page-break-before:always;display:none;"></p><h2 class="c3" id="h.qo56k0pr1b1c"><span>Part 6: &quot;Level sampling&quot; with mipmaps for texture mapping</span></h2><p class="c1"><span class="c0">A problem with our images generated with pixel sampling from the previous step is that different parts of the image look &ldquo;better&rdquo; than the others. For example, if we have a picture of a tree with the Berkeley Campanile in the background, we might want to see some granularity on the tree to see some individual leaves rather than it being all one color. However on the background the texture should and will be different, such as the stone wall or sky.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">As such we take the idea of level sampling. To do this we first preprocess our texture mapping to store multiple &ldquo;levels&rdquo;, where each level is a lower and lower resolution image until the last image is just a single pixel. </span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Then for every pixel sample we want to rasterize, we look at how fast the texture changes from pixel to pixel. To do this we calculate the partial derivatives of u and v w.r.t x and y. From this we can calculate a length L of the bounding box around a point inside of which the texture mapping is relatively the same (change is small). As such, if L is big then we know the texture isn&rsquo;t rapidly changing so we can use a lower resolution image (higher level mipmap). </span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c12">Tradeoffs</span><span class="c0">:</span></p><p class="c1"><span class="c4">Tradeoffs in Time Complexity:</span></p><p class="c1"><span class="c0">As mentioned before, we know that sampling more times per pixel will increase time and space complexity so if performance needs to be optimized then increasing sample rate may not be the primary option. Also, a nearest neighbor pixel sampling method will be faster than a bilinear sampling method. This is because for every uv texel we want to compute, we only have to look at one nearest texel rather than 4. And finally, a nearest level sampling will always be faster than a linear level as we only have to search through one mipmap level rather than two. </span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c4">Tradeoffs in Space:</span></p><p class="c1"><span class="c0">Similar to the time tradeoffs in time, it stands to reason that increasing sample_rate means we must store all of the samples we gather somewhere. The memory complexity gets multiplied by a factor of O(sample_rate). Between nearest neighbor pixel sampling and bilinear sampling, it is clear that bilinear is more costly because we have to store 4 texels in memory rather than 1. While the mipmaps are precomputed, the speed of lookups compared with having to store 2 levels worth of data for every sample point undoubtedly increases memory usage. </span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c4">Tradeoffs in Antialiasing:</span></p><p class="c1"><span class="c0">This is probably the more interesting and nuanced tradeoff section. First and foremost, increasing sample_rate seemed to increase antialiasing the most dramatically from most of the pictures. However increasing the sampling rate gave smaller and smaller returns especially when jumping from different pixel sampling methods or different level setting methods. Moreover, when zooming into the image, it does not provide that much of a boost as it did for smaller images. This is especially true for pictures such as the berkeley crest picture. I was not able to make out the letters without supersampling or magnification but with some magnification, the increase in supersampling did not drastically change the output. All in all, with nothing else super sampling gives the best tool for antialiasing, but gives much smaller returns when combined with other sampling methods. The tradeoffs in antialiasing between the pixel sampling techniques were highly dependent on the type of image used. As seen in problem 5 with the map of Italy, bilinear sampling was extremely helpful to smooth the varying colors of the landscape and water. This is in contrast to the nearest-neighbor approach that resulted in a more pixelated image. If the resolution of the screen is high enough, or the picture is made of clearly delineated chunks, it may be more beneficial to use nearest neighbor. Finally, when comparing the anti-aliasing effects of level 0, nearest-level, and bilinear level sampling. Most notably, level 0 surprisingly looked very well with supersampling and bilinear pixel sampling when the image resolution was high enough. However, when the image became smaller or our screen didn&rsquo;t have enough pixels, the benefits of nearest level and bilinear shined through. From the images, it became apparent that nearest-level should generally be reserved for minimal amounts of minification. This is because small images suffer from harsh transitions and jaggies which only bilinear can effectively mitigate (assuming no super sampling). Conversely, bilinear may not work as well for non-small images super well as it may make this too smooth, making the image blurry. </span></p><p class="c1 c2"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Screenshots:</span></p><p class="c1"><span class="c0">L_ZERO and P_NEAREST</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 506.50px; height: 379.88px;"><img alt="" src="images/image11.png" style="width: 506.50px; height: 379.88px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">L_ZERO and P_LINEAR</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 503.50px; height: 377.63px;"><img alt="" src="images/image12.png" style="width: 503.50px; height: 377.63px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0">L_NEAREST and P_NEAREST</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 542.50px; height: 406.88px;"><img alt="" src="images/image13.png" style="width: 542.50px; height: 406.88px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0">L_NEAREST and P_LINEAR</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 490.50px; height: 367.40px;"><img alt="" src="images/image3.png" style="width: 490.50px; height: 367.40px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></body></html>